#-*- mode: org; -*-

* Коментарии
Все что заключено в двойные кавычки, является коментарием. Исключением является сингулярная форма пространства - тут коментарии не допустимы, т.е. упоминание двойных ковычек в сингулярном пространстве подразумевает наличие одноименного атома.
#+BEGIN_EXAMPLE c++
  {
      + >> {1 3}    "this is one line comment"

      "this is multiline
      comment block..."

      (in singular space "comments" are
       not allowed, because the double
       quotas are interpreted as atom name)
  }
#+END_EXAMPLE
* Символы
** Атомы
/Атом/ - элементарный /символ/, характеризуется исключительно именем.
*** Именование
/Атом/ всегда принадлежит (определяется) в некотором _лексическом контексте_, иными словами, любой /атом/ всегда принадлежит некоторому множеству. С лексической точки зрения, различают два вида множества:
- Регулярное множество;
- Сингулярное множество;
Правила именования атома зависят от типа его _лексического контекста_.
**** Правила именования атомов в регулярном множестве
Имя атома может состоять как из /экранированых/ так и из /неэкранированых/ символов.
Условно экранирование может быть разделено на два типа:
1. Экранирование одиночного символа - экранируемый символ предворяется символом обратной косой черты (\), пример:
   #+BEGIN_EXAMPLE
     {
         ato\m    "the 'm' character is escaped"
     }
   #+END_EXAMPLE
2. Экранирование всех (лишь группы?) символов составляющих имя атома - имя атома обрамляется cимволом (|), пример:
   #+BEGIN_EXAMPLE
     {
         |atom|    "equal to \a\t\o\m"
     }
   #+END_EXAMPLE

Правила:
+ Экранирование обязательно, *только* для следующих символов (перечисленны через запятую): {, }, (, ), ", <space>, <\n>, <\r>, <\t>, \, |
+ Если симол цитирования (') стоит в первой позиции имени атома, то он также требует экранирования (т.к. иначе он будет трактоваться не как часть имени атома, а как цитирование атома);

#+BEGIN_EXAMPLE space
  {
      atom
      1+2=3               "just one atom"
      1 + 2 = 3           "5 atoms"
      quote_in_back'

      hello\ world
      middle\ 'quote
      \'quote\ in\ front
      
      |hello world|
      |middle 'quote|
      |'quote in front|
  }
#+END_EXAMPLE
**** Правила именования атомов в сингулярном множестве
Сингулярное множество предпологает под собой множество односимвольных атомов. В регулярном множестве не допустимо коментирование, т.к. двойная кавычка будет рассматриваться как очередной атом, пример:
#+BEGIN_EXAMPLE space
  (hello world)    "here we have space which holds 11 atoms"
  ("quoted" word)  "here we have 13 atoms"
#+END_EXAMPLE

Правила:
+ Экранирование обязательно, только для следующих символов (перечисленны через запятую): ), '
+ Экранирование примененное к <\n> означает игноррирование этого символа (т.е. не трактовать его как атом)
** Множества
/Множества/ это разряд/класс /символов/, которые в отличие от /атомов/, вбирают в себя/состоят из других /символов/. К множествам относятся: 
- Пространство;
- Cубъект;
- Перспектива;
/Множество/, может задаваться следующими формами:
1. Регулярное множество
2. Сингулярное множество

Обе формы множества различны только с лексической точки зрения, в то время как семантика их полностью идентична. Различие заключается в том, что в регулярном множестве, в качестве делимитера элементов, играет роль неэкранированный пробельный символ (пробел, табуляция, новая строка и пр.), а в сингулярном множестве все атомы односимвольные, т.е. в сингулярном множестве нет необходимости в делимитерах.
#+BEGIN_EXAMPLE
  (ab e)    "4 atoms: a, b, <space>, e"
  {ab e}    "2 atoms: ab, e"
#+END_EXAMPLE

При транслировании программы, множество стоящее на самом верхнем уровне (т.е. множество вбирающее в себя все остальные лексические единицы) рассматриваться как /субъект/, т.е. оно транслирруется в /символ-субъект/. Трансляция в символ зависит от транслируемого символа, например:
#+BEGIN_EXAMPLE
  {
      a >> b
  }
#+END_EXAMPLE
тут, с *лексической точки зрения* мы видем множество и 3 символа внутри него: a, >>, b. Т.к. это множество является множеством стоящим в самом вержу иерархии символов, то мы, его начинаем расматривать (*семантическая точка зрения*) как /субъект/. Рассматривая это множество как /субъект/ мы соответсвенно, должны произвести разбор содержимого множества как субъекта, поэтому мы теперь уже видим не 3 атома, а один символ - /эмиссия/, который в свою очередь включает в себя 2 символа: a, b которые мы должны начать рассматривать не как атомы или множества а как /субъект/ и /пространство/ соответсвенно.
*** Субъект
**** Алиасы
/Алиасы/ это псевдонимы LST-сущностей. /Алиасы/ выражаются при помощи атомамов. Источниками /алиасов/ являются [[Отражение][/отражения/]].

Введение алиасов, дает возможность задавать LST-сущностям короткие имена.
#+BEGIN_EXAMPLE
  {
      couple = {1 2}    "couple is an alias, which refers to the LST {1 2}"
      sum >> couple     "equals to sum >> {1 2}"
  }
#+END_EXAMPLE
В примере выше, при помощи [[Отражение][/отражения/]], мы ввели алиас /couple/. Важно, заметить, что алиасы - это чисто синтаксические сущности, сущсности времени трансляции, т.е. они существуют только во время постройки SST субъекта, и не входят в сам SST. Любое упоминание couple трактуется как {1 2}, т.е. после задания алиаса использовать оригинальный /атом/ напрямую становится невозможным, для того чтобы сохранить возможность использования couple как одноименного атома необходимо, до введения алиаса couple, ввести дополнительный алиас на couple:
#+BEGIN_EXAMPLE
  {
      cuuple' = couple  "alias to couple, for future usage"

      couple = {1 2}    "couple is an alias, which refers to the LST {1 2}"
      sum >> couple     "equals to sum >> {1 2}"
      echo >> {couple'}  "use the original couple atom"
  }
#+END_EXAMPLE
***** Предопределенные алиасы
В room, существует множество предопределенных алиасов:

 ______________________________________________________
| имя алиаса | LST-сущность на которую алиас ссылается |
|------------+-----------------------------------------|
| self       | LST самого субъекта                     |
| modules    | множество модулей                       |
 ------------------------------------------------------

также в это множество входят все встроенный субъекты и пространства.

*** Перспектива
- Перспектива :: это [[Отражение][/отражение/]] пространства в которое попал субъект.

Перспектива описывает то что видит субъект оказавшись в пространстве (например в следствии эмисии или трансформации). Задавая перспективы мы задаем различные сценарии поведения субъекта. Иными словами, перспектива это условие при котором применимы описываемые ею (нижестоящие декларации).
Перспектива, будучи [[Отражение][/отражением/]], может являеться источником алиасов).

Ниже приведен пример субъекта который содержит 2 перспективы, первая  описывает шаблон пространства из одного произвольного элемента, вторая описывает пространство с произвольным числом элеметов и при этом не налагает отношения порядка: 
#+BEGIN_EXAMPLE
  {a}                 "first perspective, denotes the condition"
      -> subj         "(conditional) declarations"
      c >> {1 a}
  <a 'b c ...>    "second perspective"
      a >> {b c}
#+END_EXAMPLE

В любом субъекте всегда есть перспектива поумолчанию - /{...}/. Два эквивалентныю друг другу примера:
#+BEGIN_EXAMPLE
  => sbj

  {a}
      -> subj
      b >> d
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  {a}
      -> subj
      b >> d
  {...}
      => abc
#+END_EXAMPLE

При резолвинге перспектив применяется (срабатывает) только *одна*, самая специфичная, (больше всего описывающая пространство) перспектива.
*** Утверждение
- Утверждение :: это [[Отражение][/отражение/]] LST-сущности.
*** Отражение
/Отражение/ - это LST-сущность отражающая тот или иной аспект room-системы. При помощи отражений в room реализуется механизм сопоставления с образцом, где отражения играхт роль образца.
**** Декларация
Отражение может быть представлено как множеством так и атомом.

В Room, отражения встречаются в двух формах:
1. [[Перспектива][Перспектива]] (задается множеством) - отражает пространство, в котором прибывает субъект;
2. [[Утверждение][Утверждение]] (может задаваться как множеством так и отдельным атомом) - отражает другую LST-сущность;

На каждую форму отражений могут накладываться те или иные ограничения по стректуре отражения, например, /перспектива/ может быть представленна только множеством, в то время как /утверждения/ могут представлять из себя как множества так и отдельные атомы.

**** Правила сопоставления
+ Атомы в отражении
  Каждому атому правило .... Алиасы вводятся сразу (т.е. в режиме on-line) => {a x y a} - последнее a является атомарным утверждением (т.к. первым a был введен алиас).

  | N | Элемент отражения | Соответствие | Вводимый алиас (имя) |
  |---+-------------------+--------------+----------------------|
  | 1 | '<atom>           | <atom>       |                      |
  | 2 | <atom>            | LST-сущность | <atom>               |
  | 3 | alias to <some>   | <some>       |                      |
  #+TBLFM: $1=@#-1
  где:
  <some> - LST-сущность
  <atom> - атом

  1. Цитирование атома отменяет трактовку данного атома как алиаса, и вводит атомарное утверждение:
     #+BEGIN_EXAMPLE
       alias_to_x = x

       {
         'x = a             "there is no alias introducing, because x is quoted,
                             it is not an alias, if a is not an alias to x,
                             then this line leads to compile-time error,
                             because the x and a is different attoms"

         'x = alias_to_x    "ok, atomic-assertion"
       } >> {...} 
     #+END_EXAMPLE
  2. Если атом не является алиасом (т.е. до этого не был декларирован как алиас), то он становится алиасом:
     #+BEGIN_EXAMPLE
       alias_to_x = x

       {
         x = a              "alias introducing, now x is an alias of a"
         'x = alias_to_x    "x is quoted, and therefore it is an atomic-assertion"
         x = alias_to_x     "error!"
       } >> {...}
     #+END_EXAMPLE
  3. Если атом является алиасом (т.е. до этого был декларирован как алиас), то в данной декларации этот атом трактуется не как алиас а как атомарное утверждение сущности на который данный алиас ссылается:
     #+BEGIN_EXAMPLE
       alias_to_x = x
       x = a                "alias introducing, now x is an alias of a"

       {
         x = a              "ok, atomic-asserion"     
         x = alias_to_x     "equals to 'a = x, i.e. if a is not an alias to x,
                             then this line leads to compile-time error"

         {x d} = {a 2}      "alias introducing, now d is an alias of 2,
                             x expands to 'a, and therefore it is an atomic-assertion,
                             it is equal to {'a d} = {a d}"
       } >> {...}
     #+END_EXAMPLE
+ Множества в отражении
  В Room, множество представляет из себя совокупность LST-сущностей (атомы и др. множества). В отличие от атомов, множества, несут в себе структуру. В данном случае под структурой понимется отношение порядка установленое над множеством. В Room, над любым множеством установлено отношение порядка. Следовательно, при рассматрении множества как элемента отражения, важно выделить два понятия:
  1. Содержимое множества;
  2. Отношение порядка (в дальнейшем структура множества);
  В процессе сопоставления множеств, в отражении, всегда принимает участие сопоставление _содержимого множества_ и, опционально, сопоставление _структуры множества_.
  - Сопоставление структуры множества ::
       eсли множество цитировано, то, в сопоставлении, помимо содержимого множества, также начинает играть роль и его структура.
       #+BEGIN_EXAMPLE
         '{a 'b c} = {1 2 b}   "fail, order is important - b not matches 2'

         {e 'f g} = {1 2 f}    "ok, order is not important,
                                first occurance of e introduces an alias e = 1
                                'f not matches 2, but matches third f
                                c introduces an alias c = 2"

       #+END_EXAMPLE
  - Сопоставление содержимого множества ::
       производится последовательно, слева направо, при этом, в зависимости от типа LST-сущности, применяются соответствующие правила сопоставленя отражений. Отсюда следует, что т.к. элементами множества могут служить другие множества, то процес сопоставления может нести рекурсивный характер. Касательно сопоставления атомов - при сопоставлении, введение алиасов производится сразуже помере чтения декларации отражения:
       #+BEGIN_EXAMPLE
         {a b a} = {1 2 3}    "error,
                               first occurance of a introduces alias a = 1
                               first occurance of b introduces alias b = 2
                               second occurance of a means atomic asserion 1 = 3 which is not correct"


         {e c e} = {1 2 1}    "ok"
       #+END_EXAMPLE

       | N | Элемент отражения | Соответствие              | Вводимый алиас (имя) |
       |---+-------------------+---------------------------+----------------------|
       | 1 | ...               | 0 или более LST-сущностей |                      |
       | 2 | .                 | 0 или одна LST-сущность   |                      |
       | 3 | <atom>...         | 0 или более LST-сущностей | <atom>...            |
       | 4 | <atom>.           | 0 или одна LST-сущность   | <atom>.              |
       #+TBLFM: $1=@#-1
       1. Безымянное троеточие не вводит никакой алиас в окружение. В одном отражении может встречаться не более одного безымянного троеточия:
          #+BEGIN_EXAMPLE
            {... x} = {a b (cd) a}        "ok, ... mathces a b cd sequence (not a complete set), x is an alias of a"
            {... x ...}  = {a b (cd) a}    "incorrect!"
          #+END_EXAMPLE
       2. Безымянное точка не вводит никаких алиасов в окружение.
          #+BEGIN_EXAMPLE
            {. x .} = {a b (cd)}      "ok, x is an alias of b, first . (dot) mathces a, second - (cd)"
            {. x .} = {a b}           "ok, x is an alias of b, first . (dot) mathces a, second - nothing"
            {. x} = {b}               "incorrect: dot mathces b, but x is nothing - which is imposible, because x doesn't dot-noted"
            {. x .} = {a b (cd) a}    "incorrect: last a is left unmatched"
          #+END_EXAMPLE
       3. Именованное троеточие вводит одноименный алиас в окружение. В одном отражении может встречаться не более одного имянновонного троеточия:
          #+BEGIN_EXAMPLE
            {x... y} = {a b (cd) a}          "ok, x... mathces a b cd sequence (not a copmlete set), y is an alias of a"
                some >> {x...}               "ok, equals to: some >> {a b (cd)}"
                some >> x...                 "incorrect: x... is not a complete set (i.e. it can't represent the spce)"
            {x... y z...}  = {a b (cd) a}    "incorrect: more than 2 ellipsis"
          #+END_EXAMPLE
       4. Именнованная точка вводит одноименный алиас в окружение.
          #+BEGIN_EXAMPLE
            {x. y z.} = {a b (cd)}    "ok, x. is an alias of a, y is an alias of b, z is an alias of (cd)"
            {x. y z.} = {a b}         "ok, x is an alias of b, y is an alias of b, z matches nothing"
            {x. y} = {b}              "incorrect: x. is an alias of b, but y is nothing - which is imposible, because y doesn't dot-noted"
            {x. y z.} = {a b (cd) a}  "incorrect!, last a is left unmatched"
          #+END_EXAMPLE
* Система модулей
Room-система (программа) состоит из модулей.
Модуль - это единица трансляции. Каждый модуль содержит LST-сущности. В каждом модуле могут существовать как именнованные LST-сущности так и безыманные.
#+BEGIN_EXAMPLE
  <
    {'standard 'writer out}
    {'examples 'factorial !}
  > = modules

  "print the factorial of x to the standard output"

  {x}
    like ! >> {x}
    -> out
#+END_EXAMPLE

* Примеры
- Факториал ::
#+BEGIN_EXAMPLE
  {a ...}
      like dec >> {a 'a '...}    "here we hide some simbols by quotation it"
  {'1 ...}                       "here (in perspective) quotation means exactess of symbol (i.e. prevent meaning as alias)"
      -> *
#+END_EXAMPLE
