#-*- mode: org; -*-

* Коментарии
Все что заключено в двойные кавычки, является коментарием. Исключением является сингулярная форма пространства - тут коментарии не допустимы, т.е. упоминание двойных ковычек в сингулярном пространстве подразумевает наличие одноименного атома.
#+BEGIN_EXAMPLE c++
  {
      + >> {1 3}    "this is one line comment"

      "this is multiline
      comment block..."

      (in singular space "comments" are
       not allowed, because the double
       quotas are interpreted as atom name)
  }
#+END_EXAMPLE
* Символы
** Атомы
/Атом/ - элементарный /символ/, характеризуется исключительно именем.
*** Именование
/Атом/ всегда принадлежит (определяется) в некотором _лексическом контексте_, иными словами, любой /атом/ всегда принадлежит некоторому множеству. С лексической точки зрения, различают два вида множества:
- Регулярное множество;
- Сингулярное множество;
Правила именования атома зависят от типа его _лексического контекста_.
**** Правила именования атомов в регулярном множестве
Имя атома может состоять как из /экранированых/ так и из /неэкранированых/ символов.
Условно экранирование может быть разделено на два типа:
1. Экранирование одиночного символа - экранируемый символ предворяется символом обратной косой черты (\), пример:
   #+BEGIN_EXAMPLE
     {
         ato\m    "the 'm' character is escaped"
     }
   #+END_EXAMPLE
2. Экранирование всех (лишь группы?) символов составляющих имя атома - имя атома обрамляется cимволом (|), пример:
   #+BEGIN_EXAMPLE
     {
         |atom|    "equal to \a\t\o\m"
     }
   #+END_EXAMPLE

Правила:
+ Экранирование обязательно, *только* для следующих символов (перечисленны через запятую): {, }, (, ), ", <space>, <\n>, <\r>, <\t>, \, |
+ Если симол цитирования (') стоит в первой позиции имени атома, то он также требует экранирования (т.к. иначе он будет трактоваться не как часть имени атома, а как цитирование атома);

#+BEGIN_EXAMPLE space
  {
      atom
      1+2=3               "just one atom"
      1 + 2 = 3           "5 atoms"
      quote_in_back'

      hello\ world
      middle\ 'quote
      \'quote\ in\ front
      
      |hello world|
      |middle 'quote|
      |'quote in front|
  }
#+END_EXAMPLE
**** Правила именования атомов в сингулярном множестве
Сингулярное множество предпологает под собой множество односимвольных атомов. В регулярном множестве не допустимо коментирование, т.к. двойная кавычка будет рассматриваться как очередной атом, пример:
#+BEGIN_EXAMPLE space
  (hello world)    "here we have space which holds 11 atoms"
  ("quoted" word)  "here we have 13 atoms"
#+END_EXAMPLE

Правила:
+ Экранирование обязательно, только для следующих символов (перечисленны через запятую): ), '
+ Экранирование примененное к <\n> означает игноррирование этого символа (т.е. не трактовать его как атом)
** Множества
/Множества/ это разряд/класс /символов/, которые в отличие от /атомов/, вбирают в себя/состоят из других /символов/. К множествам относятся: 
- Пространство;
- Cубъект;
- Перспектива;
/Множество/, может задаваться следующими формами:
1. Регулярное множество
2. Сингулярное множество
3. Свободное множество

Первая и вторая формы множества именют своим различием только лексику, в то время как семантика их полностью идентична. Различие заключается в том, что в регулярном множестве, в качестве делимитера элементов, играет роль неэкранированный пробельный символ (пробел, табуляция, новая строка и пр.), а в сингулярном множестве все атомы односимвольные, т.е. в сингулярном множестве нет необходимости в делимитерах.
#+BEGIN_EXAMPLE
  (ab e)    "4 atoms: a, b, <space>, e"
  {ab e}    "2 atoms: ab, e"
#+END_EXAMPLE
Третяя форма множества (свободное), в лексическом плане, идентична регулярному множеству (т.е. используются теже делимитеры), но в семантическом плане, оно отличается от первых двух форм множеств (регулярного и сингулярного) тем что на этом множестве не установленно отношение порядка.
#+BEGIN_EXAMPLE
  <ab e> = <e ab>    "ok"
  (ab e) = (e ba)    "error"
  {ab e} = {e ab}    "error"
#+END_EXAMPLE

При транслировании программы, множество стоящее на самом верхнем уровне (т.е. множество вбирающее в себя все остальные лексические единицы) рассматриваться как /субъект/, т.е. оно транслирруется в /символ-субъект/. Трансляция в символ зависит от транслируемого символа, например:
#+BEGIN_EXAMPLE
  {
      a >> b
  }
#+END_EXAMPLE
тут, с *лексической точки зрения* мы видем множество и 3 символа внутри него: a, >>, b. Т.к. это множество является множеством стоящим в самом вержу иерархии символов, то мы, его начинаем расматривать (*семантическая точка зрения*) как /субъект/. Рассматривая это множество как /субъект/ мы соответсвенно, должны произвести разбор содержимого множества как субъекта, поэтому мы теперь уже видим не 3 атома, а один символ - /эмиссия/, который в свою очередь включает в себя 2 символа: a, b которые мы должны начать рассматривать не как атомы или множества а как /субъект/ и /пространство/ соответсвенно.
*** Субъект
**** Алиасы
/Алиасы/ это псевдонимы LST-сущностей. /Алиасы/ выражаются при помощи атомамов. Источниками /алиасов/ являются [[Отражение][/отражения/]] (т.е. в том числе [[Перспектива][/перспективы/]]).

Введение алиасов, дает возможность задавать LST-сущностям короткие имена.
#+BEGIN_EXAMPLE
  {
      couple = {1 2}    "couple is an alias, which refers to the LST {1 2}"
      sum >> couple     "equals to sum >> {1 2}"
  }
#+END_EXAMPLE
В примере выше, при помощи [[%D0%9E%D1%82%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5][/отражения/]], мы ввели алиас /couple/. Важно, заметить, что алиасы - это чисто синтаксические сущности, сущсности времени трансляции, т.е. они существуют только во время постройки SST субъекта, и не входят в сам SST. Любое упоминание couple трактуется как {1 2}, т.е. после задания алиаса использовать оригинальный /атом/ напрямую становится невозможным, для того чтобы сохранить возможность использования couple как одноименного атома необходимо, до введения алиаса couple, ввести дополнительный алиас на couple:
#+BEGIN_EXAMPLE
  {
      cuuple' = couple  "alias to couple, for future usage"

      couple = {1 2}    "couple is an alias, which refers to the LST {1 2}"
      sum >> couple     "equals to sum >> {1 2}"
      echo >> {couple'}  "use the original couple atom"
  }
#+END_EXAMPLE
***** Предопределенные алиасы
В room, существует множество предопределенных алиасов:

 ______________________________________________________
| имя алиаса | LST-сущность на которую алиас ссылается |
|------------+-----------------------------------------|
| self       | LST самого субъекта                     |
| modules    | множество модулей                       |
 ------------------------------------------------------

также в это множество входят все встроенный субъекты.

***** Декларация алиасов
Семантика введения алиасов:
1. Цитирование атома в декларации, отменяет трактовку данного атома как алиаса, и вводит атомарное утверждение:
   #+BEGIN_EXAMPLE
     {
         alias_to_x = x

         {
             'x = a             "there is no alias introducing, because x is quoted,
                                 it is not an alias, if a is not an alias to x,
                                 then this line leads to compile-time error,
                                 because the x and a is different attoms"

             'x = alias_to_x    "ok, atomic-assertion"
         } >> {...} 
     }
   #+END_EXAMPLE
2. Если атом, упомянутый в декларации не является алиасом (т.е. до этого не был декларирован как алиас), то он становится алиасом:
   #+BEGIN_EXAMPLE
     {
         alias_to_x = x

         {
             x = a              "alias introducing, now x is an alias of a"

             {'x d} = {alias_to_x 2}    "alias introducing, now d is an alias of 2,
                                         x is quoted, and therefore it is an atomic-assertion"

             some >> {x ...}    "equals to some >> {a ...}"

         } >> {...}
     }
   #+END_EXAMPLE
3. Если атом, упомянутый в декларации является алиасом (т.е. до этого был декларирован как алиас), то в данной декларации этот атом трактуется не как алиас а как атомарное утверждение сущности на который данный алиас ссылается:
   #+BEGIN_EXAMPLE
     {
         alias_to_x = x
         x = a              "alias introducing, now x is an alias of a"
         
         {
             x = a              "ok, atomic-asserion"     
             x = alias_to_x     "equals to 'a = x, i.e. if a is not an alias to x,
                                 then this line leads to compile-time error"

             {x d} = {a 2}      "alias introducing, now d is an alias of 2,
                                 x expands to 'a, and therefore it is an atomic-assertion,
                                 it is equal to {'a d} = {a d}"
         } >> {...}
     }
   #+END_EXAMPLE

*** Перспектива
- Перспектива :: это [[Отражение][/отражение/]] пространства в которое попал субъект.

Перспектива описывает то что видит субъект оказавшись в пространстве (например в следствии эмисии или трансформации). Задавая перспективы мы задаем различные сценарии поведения субъекта. Иными словами, перспектива это условие при котором применимы описываемые ею (нижестоящие декларации).
Перспектива, будучи [[Отражение][/отражением/]], может являеться источником алиасов).

Ниже приведен пример субъекта который содержит 2 перспективы, первая  описывает шаблон пространства из одного произвольного элемента, вторая описывает пространство с произвольным числом элеметов и при этом не налагает отношения порядка: 
#+BEGIN_EXAMPLE
  {a}                 "first perspective, denotes the condition"
      -> subj         "(conditional) declarations"
      c >> {1 a}
  <a 'b c ...>    "second perspective"
      a >> {b c}
#+END_EXAMPLE

В любом субъекте всегда есть перспектива поумолчанию - /{...}/. Два эквивалентныю друг другу примера:
#+BEGIN_EXAMPLE
  => sbj

  {a}
      -> subj
      b >> d
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  {a}
      -> subj
      b >> d
  {...}
      => abc
#+END_EXAMPLE

При резолвинге перспектив применяется (срабатывает) только *одна*, самая специфичная, (больше всего описывающая пространство) перспектива.

* Система модулей
- Программа на room (далее /room-система/ или просто /система/) :: представляет из себя совокупность модулей.
- Модуль :: единица трансляции, описывает субъект.

#+BEGIN_EXAMPLE
  <
    {'standard 'writer out}
    {'examples 'factorial !}
  > = modules

  "print the factorial of x to the standard output"

  {x}
    like ! >> {x}
    -> out
#+END_EXAMPLE

* Примеры
- Факториал ::
#+BEGIN_EXAMPLE
  {a ...}
      like dec >> {a 'a '...}    "here we hide some simbols by quotation it"
  {'1 ...}                       "here (in perspective) quotation means exactess of symbol (i.e. prevent meaning as alias)"
      -> *
#+END_EXAMPLE
