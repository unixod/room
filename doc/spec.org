#-*- mode: org; -*-

* Коментарии
Все что заключено в двойные кавычки, является коментарием. Исключением является сингулярная форма пространства - тут коментарии не допустимы, т.е. упоминание двойных ковычек в сингулярном пространстве подразумевает наличие одноименного атома.
#+BEGIN_EXAMPLE c++
  {
      + >> {1 3}    "this is one line comment"

      "this is multiline
      comment block..."

      (in singular space "comments" are
       not allowed, because the double
       quotas are interpreted as atom name)
  }
#+END_EXAMPLE
* Символы
** Атомы
/Атом/ - элементарный /символ/, характеризуется исключительно именем.
*** Именование
/Атом/ всегда принадлежит (определяется) в некотором _лексическом контексте_, иными словами, любой /атом/ всегда принадлежит некоторому множеству. С лексической точки зрения, различают два вида множества:
- Регулярное множество;
- Сингулярное множество;
Правила именования атома зависят от типа его _лексического контекста_.
**** Правила именования атомов в регулярном множестве
Имя атома может состоять как из /экранированых/ так и из /неэкранированых/ символов.
Условно экранирование может быть разделено на два типа:
1. Экранирование одиночного символа - экранируемый символ предворяется символом обратной косой черты (\), пример:
   #+BEGIN_EXAMPLE
     {
         ato\m    "the 'm' character is escaped"
     }
   #+END_EXAMPLE
2. Экранирование всех (лишь группы?) символов составляющих имя атома - имя атома обрамляется cимволом (|), пример:
   #+BEGIN_EXAMPLE
     {
         |atom|    "equal to \a\t\o\m"
     }
   #+END_EXAMPLE

Правила:
+ Экранирование обязательно, *только* для следующих символов (перечисленны через запятую): {, }, (, ), ", <space>, <\n>, <\r>, <\t>, \, |
+ Если симол цитирования (') стоит в первой позиции имени атома, то он также требует экранирования (т.к. иначе он будет трактоваться не как часть имени атома, а как цитирование атома);

#+BEGIN_EXAMPLE space
  {
      atom
      1+2=3               "just one atom"
      1 + 2 = 3           "5 atoms"
      quote_in_back'

      hello\ world
      middle\ 'quote
      \'quote\ in\ front
      
      |hello world|
      |middle 'quote|
      |'quote in front|
  }
#+END_EXAMPLE
**** Правила именования атомов в сингулярном множестве
Сингулярное множество предпологает под собой множество односимвольных атомов. В регулярном множестве не допустимо коментирование, т.к. двойная кавычка будет рассматриваться как очередной атом, пример:
#+BEGIN_EXAMPLE space
  (hello world)    "here we have space which holds 11 atoms"
  ("quoted" word)  "here we have 13 atoms"
#+END_EXAMPLE

Правила:
+ Экранирование обязательно, только для следующих символов (перечисленны через запятую): ), '
+ Экранирование примененное к <\n> означает игноррирование этого символа (т.е. не трактовать его как атом)
** Множества
/Множества/ это разряд/класс /символов/, которые в отличие от /атомов/, вбирают в себя/состоят из других /символов/. К множествам относятся: 
- Пространство;
- Cубъект;
- Перспектива;
Лексически, /множества/, могут задаваться двумя формами:
1. Регулярное множество
2. Сингулярное множество

При транслировании программы, множество стоящее на самом верхнем уровне (т.е. множество вбирающее в себя все остальные лексические единицы) рассматриваться как /субъект/, т.е. оно транслирруется в /символ-субъект/. Трансляция в символ зависит от транслируемого символа, например:
#+BEGIN_EXAMPLE
  {
      a >> b
  }
#+END_EXAMPLE
тут, с *лексической точки зрения* мы видем множество и 3 символа внутри него: a, >>, b. Т.к. это множество является множеством стоящим в самом вержу иерархии символов, то мы, его начинаем расматривать (*семантическая точка зрения*) как /субъект/. Рассматривая это множество как /субъект/ мы соответсвенно, должны произвести разбор содержимого множества как субъекта, поэтому мы теперь уже видим не 3 атома, а один символ - /эмиссия/, который в свою очередь включает в себя 2 символа: a, b которые мы должны начать рассматривать не как атомы или множества а как /субъект/ и /пространство/ соответсвенно.
*** Субъект
**** Алиасы
/Алиасы/ это атомы которые являются псевдонимами. При субъективном разборе, есть возможность задания (введения) алиасов, тем самым получая возможность задавать LST-сущностям короткие имена.
#+BEGIN_EXAMPLE
  {
      couple = {1 2}    "couple is an alias, which refers to the LST {1 2}"
      sum >> couple     "equals to sum >> {1 2}"
  }
#+END_EXAMPLE
В примере выше, /couple/ является ялиасом, важно, заметить, что алиасы - это чисто синтаксические сущности, сущсности времени трансляции, т.е. они существуют только во время постройки SST субъекта, и не входят в сам SST.
***** Декларация алиасов
Семантика введения алиасов:
1. Цитирование атома в декларации, отменяет трактовку данного атома как алиаса, и вводит атомарное утверждение:
   #+BEGIN_SRC 
    {
        'x = a        "there is no alias introducing, x is not an alias
                       because it is quoted,
                       if a is not an alias, then this line leads to compile-time error,
                       because the x and a is different attoms"

        'x = ?x       "ok, atomic-assertion"
    }
   #+END_SRC
2. Если атом, упомянутый в декларации не является алиасом (т.е. до этого не был декларирован как алиас), то он становится алиасом:
   #+BEGIN_SRC 
    {
        x = a              "alias introducing, now x is an alias of a"
        some >> {x ...}    "equal to some >> {a ...}"

        {'x d} = {?x 2}    "alias introducing, now d is an alias of 2, x is quoted, and therefore it is an atomic-assertion"
    }
   #+END_SRC
3. Если атом, упомянутый в декларации является алиасом (т.е. до этого был декларирован как алиас), то в данной декларации этот атом трактуется не как алиас а как атомарное утверждение сущности на который данный алиас ссылается:
   #+BEGIN_SRC 
    {
        x = a              "alias introducing, now x is an alias of a"
        
        {x d} = {a 2}      "alias introducing, now d is an alias of 2, x expands to 'a, and therefore it is an atomic-assertion,
                           "it is equal to {'a d} = {a d}"
                           
    }
   #+END_SRC

#+BEGIN_SRC 
 {
     x = {a b c}   "alias introducing, x setted to the {a b c} set (neither subject, space nor perspective, just LST)"     
 }
#+END_SRC

#+BEGIN_SRC 
 {
     x = a         "alias introducing, x is "
     
     {
         x = {a b c}   "there is no alias introducing, x was defined before, therefore
                        it is a statement which leads to a compile time error, because
                        x is not an {a b c} but an atom a"
                       
     }

     {
        x = a          "not alias introducing, but it is ok"
     }
 }
#+END_SRC

#+BEGIN_SRC 
 {
     ...               "there are no x-alias introducing" 
     
     {
         x = {a b c}   "alias introducing"
         sbj >> x
     }

     {
        x = a          "alias introducing"
        sbj >> {x ...}
     }
 }
#+END_SRC

*** Перспектива
Перспектива это описание того что видит субъект оказавшись в пространстве (например в следствии эмисии или трансформации). Задавая перспективы мы задаем различные сценарии поведения субъекта. Иными словами, перспектива это условие при котором применимы описываемые ею (нижестоящие декларации). Перспектива выражается в виде шаблона пространства, тем самым она является источником алиасов (т.е. можжет вводить алиасы). При использовании перспективы, как источника алиасов, применяются правила [[Алиасы][eдиннной семантики алиасов]].

Ниже приведен пример субъекта который содержит перспективу, описывающую шаблон пространства из одного произвольного элемента.
#+BEGIN_EXAMPLE
  {
      {a}           "<--- the perspective (condition)"
          -> subj   "(conditional) declarations"
          c >> {1 a}
  }
#+END_EXAMPLE

Для того чтобы элемент перспективы описывал точное совпадение а не алиас, его необходимо цитировать. Ниже приводится пример описания такой перспективы, она задает шаблон при котором, пространство должно содерждать в себе исключительно один /атом/ *a*.
#+BEGIN_EXAMPLE
  {
      {'a}   
          -> subj
          b >> d
  }
#+END_EXAMPLE

Формат описания перспективы дает нам возможность задавать последовательности неизвестной длины, для этого необходимо использовать троеточие. Ниже дан пример в котором использован символ-троеточие, в данном случае он также как и *a* является синонимом, но только синонимом неизвестной последовательности символов:
#+BEGIN_EXAMPLE
  {
      {... a}
          -> subj
          b >> d
  }
#+END_EXAMPLE

Любое описание субъекта содержит перспективу в явном или неявном виде. В любом субъекте всегда есть перспектива поумолчанию - /{...}/. Два эквивалентныю друг другу примера:
#+BEGIN_EXAMPLE
  {
      => abc
      {... a}
          -> subj
          b >> d
  }
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  {
      {... a}
          -> subj
          b >> d
      {...}
          => abc
  }
#+END_EXAMPLE

При резолвинге перспектив применяется (срабатывает) только *одна*, самая специфичная, (больше всего описывающая пространство) перспектива.


* Примеры
- Факториал ::
#+BEGIN_EXAMPLE
  {a ...}
      like dec >> {a 'a '...}    "here we hide some simbols by quotation it"
  {'1 ...}                       "here (in perspective) quotation means exactess of symbol (i.e. prevent meaning as alias)"
      -> *
#+END_EXAMPLE
