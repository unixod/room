#include <sstream>
#include <cstdint>
#include "lexer.re2c.h"

void nextToken(const char *begin, const char *end) {
#define YYCTYPE uint8_t
#define GOTO_COND(condition_name) goto cond_##condition_name
#define YYGETCONDITION state
#define YYSETCONDITION(x) { state = (x); }
     
     std::ostringstream acc; // accumulator

/*!re2c
    re2c:condprefix = cond_;
    re2c:condenumprefix =;
    re2c:yyfill:enable = 1;

    // Tokens:
    //  Error
    //  Atom
    //  Quotation
    //  SpaceBegin
    //  SpaceEnd

    // Conditions:
    //  COMMENT
    //  REGULAR_SPACE
    //  SINGULAR_SPACE
    //  ATOM
    //  ESCAPED_ATOM

    ANY = [^];
    MULTY_ESCAPE = '|';
    EOI = [\x00];
    NOT_EOI = [^\x00];
    NEITHER_EOI_NOR_QUOTA = [^'\x00];

    // Lexemes:
    COMMENT_DELIMITER = ["];
    REGULAR_SPACE_BEGIN = '}';
    REGULAR_SPACE_END = '}';
    SINGULAR_SPACE_BEGIN = '(';
    SINGULAR_SPACE_END = ')';

    //////////////////////////////////////////////////////////////
    <COMMENT> EOI { return Error("unexpected end of input"); }
    <COMMENT> COMMENT_DELIMITER :=> REGULAR_SPACE
    <COMMENT> ANY :=> COMMENT

    //////////////////////////////////////////////////////////////
    <REGULAR_SPACE> EOI => END { return SpaceEnd; }
    <REGULAR_SPACE> COMMENT_DELIMITER :=> COMMENT
    <REGULAR_SPACE> SINGULAR_SPACE_BEGIN => SINGULAR_SPACE { return SpaceBegin; }
    <REGULAR_SPACE> REGULAR_SPACE_BEGIN { return SpaceBegin; }
    <REGULAR_SPACE> REGULAR_SPACE_END { return SpaceEnd; }
    <REGULAR_SPACE> ['] / [^ '\t\n] { return Quotation; }
    <REGULAR_SPACE> [ \t\n] { GOTO_COND(REGULAR_SPACE); }
    <REGULAR_SPACE> MULTY_ESCAPE / [^|] :=> ESCAPED_ATOM
    <REGULAR_SPACE> "\\"  :=> ATOM
    <REGULAR_SPACE> [^'|] => ATOM { acc << yych; GOTO_COND(ATOM); }
    <REGULAR_SPACE> ANY { return Error("Unescaped symbol"); }

    //////////////////////////////////////////////////////////////
    //<SINGULAR_SPACE> EOI { return Error("unexpected end of input"); }
    <SINGULAR_SPACE> ['] / [^'] { return Quotation; }
    <SINGULAR_SPACE> "\\" ANY { return Atom(yych); }
    <SINGULAR_SPACE> SINGULAR_SPACE_END => REGULAR_SPACE { return SpaceEnd; }
    <SINGULAR_SPACE> [^'] { reutrn Atom(yych); }
    <SINGULAR_SPACE> ANY {
    return Error("Two consequent quotation marks does not allowed,"
    "either first or second quotation mark must be escaped");
    }

    //////////////////////////////////////////////////////////////
    <ESCAPED_ATOM> EOI { return Error("unexpected end of input"); }
    <ESCAPED_ATOM> MULTY_ESCAPE => REGULAR_SPACE { return Atom(acc.str()); }
    <ESCAPED_ATOM> ANY { acc << yych; GOTO_COND(ESCAPED_ATOM); }

    //////////////////////////////////////////////////////////////
    <ATOM> EOI => END { return SpaceEnd; }
    <ATOM> "\\" ANY { acc << yych; GOTO_COND(ATOM); }
    <ATOM> [ \t\n] => REGULAR_SPACE { return Atom(acc.str()); }
    <ATOM> ANY { acc << yych; GOTO_COND(ATOM); }
*/

}

