#include <sstream>
#include <cstdint>
#include "lexer.re2c.h"
#include "room/core/token.h"

struct LexerState {
    typedef uint8_t CharType;
    const CharType *begin;
    const CharType *lexemeStart;
    const CharType *lexemeEnd;
    const CharType *end;
    YYCONDTYPE cond;
    void refill(std::size_t) {}
};

using namespace room::core;

token::Class nextToken(LexerState state) {
#   define GOTO_COND(condition_name) goto cond_##condition_name
#   define YYGETCONDITION() state.cond
#   define YYSETCONDITION(x) { state.cond = (x); }
#   define YYFILL(x)  state.refill(x)

    typedef LexerState::CharType YYCTYPE;
    const YYCTYPE *YYCURSOR = state.begin;
    const YYCTYPE *YYLIMIT = state.end;

/*!re2c
    re2c:indent:string = "    ";
    re2c:condprefix = cond_;
    re2c:condenumprefix =;
    re2c:yyfill:enable = 1;

    // Tokens:
    //  Error
    //  Atom
    //  Quotation
    //  SpaceBegin
    //  SpaceEnd

    // Conditions:
    //  COMMENT
    //  REGULAR_SPACE
    //  SINGULAR_SPACE
    //  ESCAPED_ATOM
    //  END

    ANY = [^];
    EOI = [\x00];
    NOT_EOI = [^\x00];
    NEITHER_EOI_NOR_QUOTA = [^'\x00];
    MUTLI_ESCAPED_ATOM = "|" [^|\x00]+ "|";
    ATOM = ([^'| \t\x00] | "\\" NOT_EOI)+;

    // Lexemes:
    COMMENT_DELIMITER = ["];
    REGULAR_SPACE_BEGIN = '}';
    REGULAR_SPACE_END = '}';
    SINGULAR_SPACE_BEGIN = '(';
    SINGULAR_SPACE_END = ')';

    //////////////////////////////////////////////////////////////
    <COMMENT, SINGULAR_SPACE> EOI
    {
        --YYCURSOR; // put back the EOI
        return token::Class::Error; // unexpected end of input
    }

    //////////////////////////////////////////////////////////////
    <COMMENT> COMMENT_DELIMITER             :=> REGULAR_SPACE
    <COMMENT> ANY                           :=> COMMENT

    //////////////////////////////////////////////////////////////
    <REGULAR_SPACE> EOI                     { --YYCURSOR; return token::Class::End; }
    <REGULAR_SPACE> COMMENT_DELIMITER       :=> COMMENT
    <REGULAR_SPACE> SINGULAR_SPACE_BEGIN    => SINGULAR_SPACE { return token::Class::SpaceBegin; }
    <REGULAR_SPACE> REGULAR_SPACE_BEGIN     { return token::Class::SpaceBegin; }
    <REGULAR_SPACE> REGULAR_SPACE_END       { return token::Class::SpaceEnd; }
    <REGULAR_SPACE> ['] / [^ '\t\n]         { return token::Class::Quotation; }
    <REGULAR_SPACE> [ \t\n]                 { ++state.lexemeStart; GOTO_COND(REGULAR_SPACE); }
    <REGULAR_SPACE> MUTLI_ESCAPED_ATOM      { return token::Class::Atom; }
    <REGULAR_SPACE> ATOM                    { return token::Class::Atom; }

    //////////////////////////////////////////////////////////////
    <SINGULAR_SPACE> ['] / [^']             { return token::Class::Quotation; }
    <SINGULAR_SPACE> "\\" ANY               { ++state.lexemeStart; return token::Class::Atom; }
    <SINGULAR_SPACE> SINGULAR_SPACE_END     => REGULAR_SPACE { return token::Class::SpaceEnd; }
    <SINGULAR_SPACE> [^']                   { return token::Class::Atom; }
    <*> ANY
    {
        return token::Class::Error; //sdf
    }
*/

}

