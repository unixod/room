#ifndef ROOM_LEXER_PRIVATE_H
#define ROOM_LEXER_PRIVATE_H

#include <functional>
#include <cstdint>
#include "lexer.re2c.conditions.h"
#include "room/core/token.h"
#include "room/lexer.h"

namespace token = room::core::token;

struct Re2CLexerState {
    typedef uint8_t CharType;
    YYCONDTYPE cond;

    // when refilling, piece between
    // the lexemeStart and lexemeEnd
    // may be stored in temporary
    // storage as needed, and in final
    // concatenated with tail of lexeme
    const CharType *lexemeStart;

    // when refilling, the following
    // pointers should be adjusted
    const CharType *lexemeEnd;
    const CharType *inputBufferEnd;
    const CharType *ctxMarker;
    const CharType *marker;
};

namespace room {

class Lexer::Private {
    token::Class nextToken(Re2CLexerState &state, std::function<void(int)> refill);

    Re2CLexerState re2State;
};


token::Class Lexer::Private::nextToken(Re2CLexerState &state, std::function<void(int)> refill) {
#   define GOTO_COND(condition_name) goto cond_##condition_name
#   define YYGETCONDITION() state.cond
#   define YYSETCONDITION(x) { state.cond = (x); }

/*!re2c
    re2c:indent:string      =   "    ";
    re2c:condprefix         =   cond_;
    re2c:condenumprefix     =   ;
    re2c:yyfill:enable      =   1;
    re2c:define:YYCTYPE     =   Re2CLexerState::CharType;
    re2c:define:YYCURSOR    =   state.lexemeEnd;
    re2c:define:YYLIMIT     =   state.inputBufferEnd;
    re2c:define:YYCTXMARKER =   state.ctxMarker;
    re2c:define:YYMARKER    =   state.marker;
    re2c:define:YYFILL      =   refill;

    ///////////////////////////////////////////////////////////////////////////
    // Lexemes:
    ANY                     =   [^];
    EOI                     =   [\x00];     // end of input
    NOT_EOI                 =   [^\x00];
    COMMENT_DELIMITER       =   ["];
    REGULAR_SPACE_BEGIN     =   '}';
    REGULAR_SPACE_END       =   '}';
    SINGULAR_SPACE_BEGIN    =   '(';
    SINGULAR_SPACE_END      =   ')';
    MUTLI_ESCAPED_ATOM      =   "|" [^|\x00]+ "|";
    ATOM                    =   ([^'| \t\x00] | "\\" NOT_EOI)+;

    ///////////////////////////////////////////////////////////////////////////
    // Notes:
    //  --state.lexemeEnd   -   means "put back the consumed symbol"
    //
    ///////////////////////////////////////////////////////////////////////////
    <COMMENT, SINGULAR_SPACE> EOI           { --state.lexemeEnd; return token::Class::Error; }

    ///////////////////////////////////////////////////////////////////////////
    <COMMENT> COMMENT_DELIMITER             :=> REGULAR_SPACE
    <COMMENT> ANY                           :=> COMMENT

    ///////////////////////////////////////////////////////////////////////////
    <REGULAR_SPACE> EOI                     { --state.lexemeEnd; return token::Class::End; }
    <REGULAR_SPACE> COMMENT_DELIMITER       :=> COMMENT
    <REGULAR_SPACE> SINGULAR_SPACE_BEGIN    => SINGULAR_SPACE { return token::Class::SpaceBegin; }
    <REGULAR_SPACE> REGULAR_SPACE_BEGIN     { return token::Class::SpaceBegin; }
    <REGULAR_SPACE> REGULAR_SPACE_END       { return token::Class::SpaceEnd; }
    <REGULAR_SPACE> ['] / [^ '\t\n]         { return token::Class::Quotation; }
    <REGULAR_SPACE> [ \t\n]                 { ++state.lexemeStart; GOTO_COND(REGULAR_SPACE); }
    <REGULAR_SPACE> MUTLI_ESCAPED_ATOM      { return token::Class::Atom; }
    <REGULAR_SPACE> ATOM                    { return token::Class::Atom; }

    ///////////////////////////////////////////////////////////////////////////
    <SINGULAR_SPACE> ['] / [^']             { return token::Class::Quotation; }
    <SINGULAR_SPACE> "\\" ANY               { ++state.lexemeStart; return token::Class::Atom; }
    <SINGULAR_SPACE> SINGULAR_SPACE_END     => REGULAR_SPACE { return token::Class::SpaceEnd; }
    <SINGULAR_SPACE> [^']                   { return token::Class::Atom; }

    ///////////////////////////////////////////////////////////////////////////
    <*> ANY                                 { return token::Class::Error; }
*/
}

} // namespace room

#endif // ROOM_LEXER_PRIVATE_H

